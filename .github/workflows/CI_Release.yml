name: Changelog and Release

on:
  push:
    branches:
      - main

permissions:
  contents: write
  pull-requests: read

jobs:
  changelog-and-release:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history for all branches and tags

      - name: Get latest tag
        id: get_latest_tag
        run: |
          # Get the latest tag, or use 0.0.0 if no tags exist
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "latest_tag=$LATEST_TAG" >> $GITHUB_OUTPUT
          echo "Latest tag: $LATEST_TAG"

      - name: Analyze commits and determine version
        id: analyze_commits
        run: |
          LATEST_TAG="${{ steps.get_latest_tag.outputs.latest_tag }}"

          # Get commits since last tag
          if [ "$LATEST_TAG" = "v0.0.0" ]; then
            COMMITS=$(git log --oneline --pretty=format:"%s")
          else
            COMMITS=$(git log ${LATEST_TAG}..HEAD --oneline --pretty=format:"%s")
          fi

          echo "Commits since $LATEST_TAG:"
          echo "$COMMITS"

          # Check if there are any new commits
          if [ -z "$COMMITS" ]; then
            echo "No new commits since last release"
            echo "skip=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Analyze commit messages for features, bugfixes, and hotfixes
          HAS_FEATURE=false
          HAS_BUGFIX=false
          HAS_HOTFIX=false

          while IFS= read -r commit; do
            commit_lower=$(echo "$commit" | tr '[:upper:]' '[:lower:]')
            if echo "$commit_lower" | grep -qE '(feat|feature)'; then
              HAS_FEATURE=true
            fi
            if echo "$commit_lower" | grep -qE '(fix|bugfix)'; then
              HAS_BUGFIX=true
            fi
            if echo "$commit_lower" | grep -qE 'hotfix'; then
              HAS_HOTFIX=true
            fi
          done <<< "$COMMITS"

          echo "Has feature: $HAS_FEATURE"
          echo "Has bugfix: $HAS_BUGFIX"
          echo "Has hotfix: $HAS_HOTFIX"

          # Remove 'v' prefix and split version
          VERSION=${LATEST_TAG#v}
          IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION"

          # Determine version bump
          if [ "$HAS_FEATURE" = true ]; then
            # Feature: bump minor version, reset patch
            MINOR=$((MINOR + 1))
            PATCH=0
          elif [ "$HAS_BUGFIX" = true ] || [ "$HAS_HOTFIX" = true ]; then
            # Bugfix or Hotfix: bump patch version
            PATCH=$((PATCH + 1))
          else
            # No recognizable change type, bump patch
            PATCH=$((PATCH + 1))
          fi

          NEW_VERSION="$MAJOR.$MINOR.$PATCH"
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "skip=false" >> $GITHUB_OUTPUT
          echo "New version: $NEW_VERSION"

      - name: Generate changelog
        if: steps.analyze_commits.outputs.skip != 'true'
        run: |
          LATEST_TAG="${{ steps.get_latest_tag.outputs.latest_tag }}"
          NEW_VERSION="${{ steps.analyze_commits.outputs.new_version }}"

          # Get commits since last tag
          if [ "$LATEST_TAG" = "v0.0.0" ]; then
            COMMITS=$(git log --oneline --pretty=format:"%s|%h|%an|%ad" --date=short)
          else
            COMMITS=$(git log ${LATEST_TAG}..HEAD --oneline --pretty=format:"%s|%h|%an|%ad" --date=short)
          fi

          # Initialize categories
          FEATURES=""
          BUGFIXES=""
          HOTFIXES=""
          OTHER=""

          # Categorize commits
          while IFS='|' read -r message hash author date; do
            message_lower=$(echo "$message" | tr '[:upper:]' '[:lower:]')

            if echo "$message_lower" | grep -qE '(feat|feature)'; then
              FEATURES="${FEATURES}- ${message} ([${hash}](https://github.com/${{ github.repository }}/commit/${hash}))\n"
            elif echo "$message_lower" | grep -qE 'hotfix'; then
              HOTFIXES="${HOTFIXES}- ${message} ([${hash}](https://github.com/${{ github.repository }}/commit/${hash}))\n"
            elif echo "$message_lower" | grep -qE '(fix|bugfix)'; then
              BUGFIXES="${BUGFIXES}- ${message} ([${hash}](https://github.com/${{ github.repository }}/commit/${hash}))\n"
            else
              OTHER="${OTHER}- ${message} ([${hash}](https://github.com/${{ github.repository }}/commit/${hash}))\n"
            fi
          done <<< "$COMMITS"

          # Create new changelog entry
          CHANGELOG_ENTRY="## [${NEW_VERSION}] - $(date +%Y-%m-%d)\n\n"

          if [ -n "$FEATURES" ]; then
            CHANGELOG_ENTRY="${CHANGELOG_ENTRY}### ✨ Features\n${FEATURES}\n"
          fi

          if [ -n "$HOTFIXES" ]; then
            CHANGELOG_ENTRY="${CHANGELOG_ENTRY}### 🚨 Hotfixes\n${HOTFIXES}\n"
          fi

          if [ -n "$BUGFIXES" ]; then
            CHANGELOG_ENTRY="${CHANGELOG_ENTRY}### 🐛 Bug Fixes\n${BUGFIXES}\n"
          fi

          if [ -n "$OTHER" ]; then
            CHANGELOG_ENTRY="${CHANGELOG_ENTRY}### 📝 Other Changes\n${OTHER}\n"
          fi

          # Create or update CHANGELOG.md
          if [ ! -f CHANGELOG.md ]; then
            echo "# Changelog" > CHANGELOG.md
            echo "" >> CHANGELOG.md
            echo "All notable changes to this project will be documented in this file." >> CHANGELOG.md
            echo "" >> CHANGELOG.md
          fi

          # Insert new entry after the header
          {
            head -n 3 CHANGELOG.md
            echo -e "$CHANGELOG_ENTRY"
            tail -n +4 CHANGELOG.md
          } > CHANGELOG.tmp && mv CHANGELOG.tmp CHANGELOG.md

          echo "Changelog updated with version ${NEW_VERSION}"

      - name: Commit and push changelog
        if: steps.analyze_commits.outputs.skip != 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add CHANGELOG.md
          git commit -m "chore: update CHANGELOG.md for v${{ steps.analyze_commits.outputs.new_version }}"
          git push

      - name: Create GitHub Release
        if: steps.analyze_commits.outputs.skip != 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          NEW_VERSION="${{ steps.analyze_commits.outputs.new_version }}"
          LATEST_TAG="${{ steps.get_latest_tag.outputs.latest_tag }}"

          # Extract the new changelog entry for release notes
          if [ "$LATEST_TAG" = "v0.0.0" ]; then
            RELEASE_NOTES=$(git log --oneline --pretty=format:"- %s")
          else
            RELEASE_NOTES=$(git log ${LATEST_TAG}..HEAD --oneline --pretty=format:"- %s")
          fi

          # Create the release
          gh release create "v${NEW_VERSION}" \
            --title "Release v${NEW_VERSION}" \
            --notes "${RELEASE_NOTES}" \
            --target main